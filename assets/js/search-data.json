{
  
    
        "post0": {
            "title": "Exploratory Data Analysis of Airbnb Accommodation in Copenhagen",
            "content": ". Note: Code sections can be made visible by using the provided buttons throughout this project . 1.0 ABSTRACT . In this project, we investigate Airbnb host listings in Copenhagen in special regard to their area of location, and what attributes are associated with them. We strive, to describe the Copenhagen landscape and the accommodation services provided by Airbnb. The goal is to create a report, that can help customers guide their decision in relation to where to book their stay while in Copenhagen, and in relation to the experience they expect for their stay. . We aim to answer our research question: How can Airbnb ensure matches and the experiences they create are positive for their customers (users), and providers (hosts)? Moreover, how can Airbnb help guide user decisions to create successful matches and positive experiences? . This paper presents an exploratory data analysis using various data processing techniques and visualization tools found in the seaborn, plotly express and matplotlib pyplot libraries for python. The analysis was conduction with special focus on how location areas affect number of listings provided on the platform, pricing, property types and room types. From our analysis we found that Brønshøj-Husum might be particular interesting families that wish to book into an entire house. . Moreover, this paper displays techniques for visualizing word strings into wordclouds and how geospatial data can be presented in an interactive manner to improve understanding of the features in the data. . 2.0 INTRODUCTION . Since 2008, Airbnb has grown from a small accommodation platform, hosted in San Francisco, to one that is now recognised throughout the world. Airbnb has revolutionized the tourism housing industry by applying a sharing economy model to the accommodation business. Today, Airbnb has become the world’s largest accommodation service provider with more accommodation options than any other accommodation business - and even more than all of them combined. As a platform, Airbnb enables people (hosts) to offer accommodation services to other people (guests), providing guests with a more unique and personalized way of experiencing the world, and often at a reasonably lower price than other accommodation options. Only just a fraction (20%) of these transactions are captured by Airbnb, which in 2019 returned 4,7 billion USD in sales revenues. . 2.1 Problem Formulation and Research Question . Data plays a key role in Airbnb’s success. For instance, data enables Airbnb to match guests and hosts and further allows the users to filter the host listings to their likings, in respect of pricing, location, number of beds, and much more. Thereby, data is essential to securing high customer satisfaction. Moreover, Airbnb can use the collected data to extract insights that can be used to improve their service offerings, guide decision making, guide marketing initiatives, and more. . As a platform, Airbnb’s sole value creation lies in creating successful matches between guests and hosts and by ensuring a positive experience for both parties. Naturally, if the platform fails to deliver a positive experience to a user, the user might neglect the platform in total, resulting in negative feedback loops. This leads us to our research question: . How can Airbnb ensure matches and the experiences they create are positive for their customers (users), and providers (hosts)? Moreover, how can Airbnb help guide user decisions to create successful matches and positive experiences? . Currently, Airbnb helps the users to create meaningful matches, by allowing the guests to limit their search for accommodation by different attributes related to the individual host listing. As such, users can easily find accommodation that meets their basic needs for accommodation; e.g. number of beds, bedrooms, price, room type, etc. However, without any knowledge of the different location areas, guests might find difficulty in choosing a location that suits their needs. . In this project, we will examine the accommodation services, listed on Airbnb for Copenhagen, in special regard to the location areas, and the attributes that are associated with them. The goal is to create a report that can guide customers to choose a location that lives up to their expectations, thereby improving the quality of the matches provided by the platform. . 3.0 METHODOLOGY . 3.1 Dataset Analysis Process . To answer the question of interest, we perform an exploratory data analysis (EDA) to gain an understanding of what features that seperates and defines neighbourhoods and the differences in their accommodation offerings. More specifically, we will zoom in on the neighbourhoods with respect to which type of room and property that are most common in the area, and how the neighbourhood affect the listing price. Moreover, the price for accommodating one person is calculated to provide an indication of wealth. . Moving on, we create an interactive map that displays each individual accommodation offering in a geospatial visualization. Through interaction the map allows the user to easily find listings, view that most expensivest listings and display where each neighbourhood is located. Furthermore, the interactivity enables zooming, moving and filtering of the data to enhance the understanding of the geospace. . Finally, we create wordcloud visualizations to display how hosts are descriping the neighbourhoods, that allows us to get a sense of which words that best describes the location areas. . 3.2 Dataset Description . The data was downloaded from the independent site: Inside Airbnb, which scrapes data from Airbnb, and makes it puplicly available for analysis. This site provides a multitude of datasets containing information on the most populated cities around the world - including Copenhagen. . The datasets provided by Inside Airbnb is as follows: (1) listings, (2) calendar, (3) reviews, (4) listings_summary, (5) reviews_summary. . We have downloaded and inspected all of the datasets. However, only the listings are assessed to be important for this project. . The most recent data set is used, which was scraped on 28th of Nov. 2020. . The listings dataset contains data about the airbnb host listings and their respective attributes. In total, there are 74 columns describing 8636 listings on the Airbnb platform. However, for this project, the following 17 attributes has been selected for analysis: . id: primary key (listings_id) | name: name of listing | description: room description | neighbourhood_overview: text description of the neighbourhood | neightbourhood_cleansed: location area cleaned from special charaters | latitude: latitude | longitude: longitude | property_type: type of the property where the room is in | room_type: type of room that is made available | accommodates: max number of people that can stay at a time | beds: number of beds in the room | bedrooms: number of bedrooms in the room | ammenties: facilities available | price: price of the room per day | number_of_reviews: number of times the listing was reviewed | review_scores_rating: average review score of the listing | . 3.3 Preprocessing Steps . As usual, before we can initialize the data exploration, we will need to preprocess the data. Overall the preprocessing will follow the following structure: . Install and Import libraries | Gather data | Data Cleaning | By utilizing the pandas library, we download and unzip the data using pandas built-in decompression tool, and then using it to create dataframes that stores the data, enabling data cleaning and manipulation. We clean the data by selecting only the 17 columns as listed previously, checking for misclassified datatypes and renaming columns and values to ease interpretation of the data. . Without further ado, let&#39;s get started! . 4.0 PROCESSING THE DATA . In this section, we will process and clean the data before initiating the exploratory data analysis. . This project is created in a colab notebook and exported to fastpages for improved readability and interactive features such as the code button provided bellow. You will find these buttons throughout this paper, however some code snippets has been hidden entirely. . If you wish to review the full line of code, please see the buttons under the headline of this post. . 4.1 Install and Import Libraries . import pandas as pd #used to store and manage the data import numpy as np import matplotlib.pyplot as plt #visualization library import plotly.express as px #visualization library used for geospatial data import seaborn as sns #Wordcloud related libraries from os import path from PIL import Image from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator . We initiate our data analysis by installing and importing the libraries for our python interpreter. For this project, we use pandas, pyplot, express, WordCloud, STOPWORDS, and ImageColorGenerator. These libraries enables us to clean and process the data and later to create meaningful visualizations. . 4.2 Gathering the Data . #Create DataFrames listings = pd.read_csv(&#39;http://data.insideairbnb.com/denmark/hovedstaden/copenhagen/2020-11-28/data/listings.csv.gz&#39;, compression=&#39;gzip&#39;) listings = listings.iloc[:,[0,4,5,6,27,29,30,31,32,33,36,37,38,39,55,59,60]] . The dataset is downloaded, unzipped and stored in a dataframe using pandas. Again using pandas, the irrelevant columns are dropped, thereby only the columns chosen for this project remains. . Now that, we have gathered the data, let us take a quick glimpse on the data: . listings.head(3) . id name description neighborhood_overview neighbourhood_cleansed latitude longitude property_type room_type accommodates bedrooms beds amenities price number_of_reviews last_review review_scores_rating . 0 6983 | Copenhagen &#39;N Livin&#39; | Lovely apartment located in the hip Nørrebro a... | Nice bars and cozy cafes just minutes away, ye... | Nrrebro | 55.68798 | 12.54571 | Private room in apartment | Private room | 2 | 1.0 | 1.0 | [&quot;Hot water&quot;, &quot;Refrigerator&quot;, &quot;Heating&quot;, &quot;Stov... | $361.00 | 168 | 2019-07-19 | 96.0 | . 1 26057 | Lovely house - most attractive area | Our lovely house in the center of the city is ... | The neighborhood is the most famous one and th... | Indre By | 55.69163 | 12.57459 | Entire house | Entire home/apt | 6 | 4.0 | 4.0 | [&quot;Kitchen&quot;, &quot;Essentials&quot;, &quot;Cooking basics&quot;, &quot;I... | $2,400.00 | 50 | 2019-12-14 | 98.0 | . 2 29118 | Best Location in Cool Istedgade | &lt;b&gt;The space&lt;/b&gt;&lt;br /&gt;The apartment is situate... | NaN | Vesterbro-Kongens Enghave | 55.67069 | 12.55430 | Entire apartment | Entire home/apt | 2 | 1.0 | 1.0 | [&quot;Hot water&quot;, &quot;Changing table&quot;, &quot;Refrigerator&quot;... | $725.00 | 22 | 2019-08-02 | 98.0 | . listings.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 8636 entries, 0 to 8635 Data columns (total 17 columns): # Column Non-Null Count Dtype -- -- 0 id 8636 non-null int64 1 name 8635 non-null object 2 description 8396 non-null object 3 neighborhood_overview 4936 non-null object 4 neighbourhood_cleansed 8636 non-null object 5 latitude 8636 non-null float64 6 longitude 8636 non-null float64 7 property_type 8636 non-null object 8 room_type 8636 non-null object 9 accommodates 8636 non-null int64 10 bedrooms 8440 non-null float64 11 beds 8584 non-null float64 12 amenities 8636 non-null object 13 price 8636 non-null object 14 number_of_reviews 8636 non-null int64 15 last_review 7337 non-null object 16 review_scores_rating 7230 non-null float64 dtypes: float64(5), int64(3), object(9) memory usage: 1.1+ MB . listings.isnull().sum() . id 0 name 1 description 240 neighborhood_overview 3700 neighbourhood_cleansed 0 latitude 0 longitude 0 property_type 0 room_type 0 accommodates 0 bedrooms 196 beds 52 amenities 0 price 0 number_of_reviews 0 last_review 1299 review_scores_rating 1406 dtype: int64 . listings.shape . (8636, 17) . From the quick glimpse, we see that not all hosts are providing a description of the neighbourhood that the listing is located at (the values appear as missing (NaN). In fact, 3700 listings appear without a description of the neighbourhood. . We find that, in the cleansed neighbourhood attribute letter &#39;ø&#39; has been removed from the name. . The Price attribute is listed as USD marked by a &#39;$&#39;, however the listing price should be denoted as DKK. Moreover, the price is interpreted as an object instead of an integer-value. Similarly, &#39;bedrooms&#39; and &#39;beds&#39; are interpreted as float types instead of intergers. Additionally, the last_review attribute should be classified as a datatime type. . 4.3 Data Cleaning . Lets try to correct the above mentioned data anomali. . We start by removing renaming the columns, and then the neighbourhood names to be easier interpretable. To correct the datatypes, some actions has to happen beforehand. For the pricing, the &#39;$&#39; and &#39;,&#39; is removed before correcting the data type. For beds and bedrooms, the missing values are filled with a zero, under the assumption, that these listings are available but does not offer either a bed or a bedroom. . #Rename columns listings.rename(columns={&#39;id&#39;:&#39;listing_id&#39;, &#39;name&#39;:&#39;listing_name&#39;, &#39;description&#39;:&#39;listing_description&#39;, &#39;neighborhood_overview&#39;:&#39;neighbourhood_description&#39;, &#39;neighbourhood_cleansed&#39;:&#39;neighbourhood&#39;}, inplace=True) #Rename Neighbourhood Values listings[&#39;neighbourhood&#39;] = listings.neighbourhood.replace( { &#39;Nrrebro&#39;:&#39;Nørrebro&#39;, &#39;sterbro&#39;:&#39;Østerbro&#39;, &#39;Amager st&#39;: &#39;Amager Øst&#39;, &#39;Vanlse&#39;: &#39;Vanløse&#39;, &#39;Brnshj-Husum&#39;:&#39;Brønshøj-Husum&#39; } ) #Fill missing values cols = [&#39;beds&#39;,&#39;bedrooms&#39;] listings[cols] = listings[cols].fillna(&#39;0&#39;) #Correct DataTypes listings = listings.astype( { &#39;bedrooms&#39;:int, &#39;beds&#39;:int, &#39;last_review&#39;:&#39;datetime64[ns]&#39; } ) #Correct Prices from $ to DKK, then DataType listings.price = listings.price.str.replace(&#39;,&#39;,&#39;&#39;) listings.price = listings.price.str.replace(&#39;$&#39;,&#39;&#39;) listings.price = listings.price.astype(float) clean = listings . We should now have clean data, that we can use to analyze the attributes of the listings. Let&#39;s end the data preprocessing, by assessing the cleaned dataframe: . clean.head() . listing_id listing_name listing_description neighbourhood_description neighbourhood latitude longitude property_type room_type accommodates bedrooms beds amenities price number_of_reviews last_review review_scores_rating . 0 6983 | Copenhagen &#39;N Livin&#39; | Lovely apartment located in the hip Nørrebro a... | Nice bars and cozy cafes just minutes away, ye... | Nørrebro | 55.68798 | 12.54571 | Private room in apartment | Private room | 2 | 1 | 1 | [&quot;Hot water&quot;, &quot;Refrigerator&quot;, &quot;Heating&quot;, &quot;Stov... | 361.0 | 168 | 2019-07-19 | 96.0 | . 1 26057 | Lovely house - most attractive area | Our lovely house in the center of the city is ... | The neighborhood is the most famous one and th... | Indre By | 55.69163 | 12.57459 | Entire house | Entire home/apt | 6 | 4 | 4 | [&quot;Kitchen&quot;, &quot;Essentials&quot;, &quot;Cooking basics&quot;, &quot;I... | 2400.0 | 50 | 2019-12-14 | 98.0 | . 3 31094 | Very central and cozy, new kitchen | &lt;b&gt;The space&lt;/b&gt;&lt;br /&gt;Welcome to our home, we ... | What else is nearby?&lt;br /&gt;To be honest, I thin... | Vesterbro-Kongens Enghave | 55.66744 | 12.55516 | Entire apartment | Entire home/apt | 3 | 1 | 3 | [&quot;TV&quot;, &quot;Heating&quot;, &quot;Kitchen&quot;, &quot;Wifi&quot;, &quot;Cable TV&quot;] | 750.0 | 17 | 2017-08-25 | 97.0 | . 5 37159 | Unique space on greatest location | Situated in the arty Nansensgade quarters and... | Our neighborhood is just the great and quit, b... | Indre By | 55.68572 | 12.56749 | Entire apartment | Entire home/apt | 4 | 2 | 3 | [&quot;Dedicated workspace&quot;, &quot;Heating&quot;, &quot;Iron&quot;, &quot;Ha... | 2369.0 | 11 | 2017-08-22 | 100.0 | . 10 69440 | Clean room in peacefull part of Cph | Adorable apartment in peaceful, green and old-... | The green and old-fashion Frederiksberg is the... | Frederiksberg | 55.68575 | 12.53567 | Private room in apartment | Private room | 1 | 1 | 1 | [&quot;Dryer&quot;, &quot;Hot water&quot;, &quot;Refrigerator&quot;, &quot;Heatin... | 318.0 | 46 | 2019-06-01 | 97.0 | . 5.0 EXPLORATORY DATA PROCESSING . So far so good, now it is time to perform some exploratory data analysis on the data. . We start of by exploring the neighbourhoods of copenhagen and how they compare in relation to pricing: . 5.1 Understanding Neighbourhoods and The Pricing Landscape . 5.1.1 Neighbourhoods in Copenhagen . neighbourhoods = listings[[&#39;neighbourhood&#39;]].value_counts().to_frame(name=&#39;total_listings&#39;).reset_index() #Viz plt.figure(figsize= (10, 10)) plt.style.use(&#39;ggplot&#39;) sns.barplot(neighbourhoods.total_listings, neighbourhoods.neighbourhood) plt.title(&#39;Accommodation Options Split by Location Area&#39;, fontdict= {&#39;fontsize&#39;: 24}) plt.xlabel(&#39;Number of Accomoddation Options&#39;, fontdict= {&#39;fontsize&#39;: 18}) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. . 5.1.2 Neighbourhood Accommodation Prices . price_nh = clean.groupby(&#39;neighbourhood&#39;).price.mean().to_frame().sort_values(by=&#39;price&#39;, ascending=False).reset_index() #Viz plt.figure(figsize= (10, 10)) plt.style.use(&#39;ggplot&#39;) sns.barplot(price_nh.price, price_nh.neighbourhood) plt.title(&#39;Accommodation Prices, split by Location area&#39;, fontdict= {&#39;fontsize&#39;: 24}) #plt.yscale(&#39;log&#39;) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. . 5.1.2 Per-Person Accommodation Price . #Calculate Average Price Per Person accommodations[&#39;price&#39;] = price_nh.price accommodations[&#39;price_perPerson&#39;] = accommodations.price/accommodations.avg_accommodation accommodations = accommodations.sort_values(by=&#39;price_perPerson&#39;, ascending=False) #Viz plt.figure(figsize= (10, 10)) plt.style.use(&#39;ggplot&#39;) sns.barplot(accommodations.price_perPerson, accommodations.neighbourhood) plt.title(&#39;Price per Person, split by Location area&#39;, fontdict= {&#39;fontsize&#39;: 24}) #plt.yscale(&#39;log&#39;) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. . 5.1.3 Conclusion on the Analysis of Neighbourhoods . By looking at the distribution of neighbourhoods it becomes evident that accommodation services as listed by the hosts are mostly situated in the inner city and the farther away you travel from the city center, the less listings can be expected on the platform. This proves great potential for guests that want a truly central location. . Unsurprisingly, the prices also tend to be higher the close we get to the city center. . To our surprise, however, if the guest travels in groups of other people, the per-person-price looks somewhat different. The average per-person-price, ranges between 200 and 400 DKK. In relation to this, the city center seems like a viable place to stay with a per-person-price of just around 250 kr. . 5.2 Analyzing Property Types and Respective Pricing . 5.2.1 Property Types in Copenhagen . properties = clean[[&#39;property_type&#39;]].value_counts().to_frame(name=&#39;listings&#39;).reset_index() #viz plt.figure(figsize= (25, 15)) plt.style.use(&#39;ggplot&#39;) sns.barplot(properties.listings[:20], properties.property_type[:20]) plt.title(&#39;Top 20 Accommodation Options Split by Property Type, log_scale&#39;, fontdict= {&#39;fontsize&#39;: 24}) plt.xlabel(&#39;Number of Accomoddation Options&#39;, fontdict= {&#39;fontsize&#39;: 18}) plt.xscale(&#39;log&#39;) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. . 5.2.2 Property Types by Neighbourhood . #Select properties listed more than 400 times listings_clean = clean[clean.property_type.isin([&#39;Entire apartment&#39;,&#39;Private room in apartment&#39;,&#39;Entire condominium&#39;,&#39;Entire house&#39;])] #Count number of listings in neighbourhoods by property type propertyCount = listings_clean.groupby([&#39;neighbourhood&#39;,&#39;property_type&#39;]).neighbourhood.count().to_frame(name = &#39;listings&#39;).reset_index() #Sum number of listings per neighbourhood propertyCount = propertyCount.merge(neighbourhoods, on=&#39;neighbourhood&#39;) #Calculate ratio of property types in the different neighbourhoods propertyCount[&#39;property_ratio&#39;] = propertyCount[&#39;listings&#39;]/propertyCount[&#39;total_listings&#39;] propertyRatio = propertyCount propertyRatio.head(10) #Viz plt.figure(figsize= (25, 15)) plt.style.use(&#39;ggplot&#39;) sns.barplot(y=&#39;property_ratio&#39;, x=&#39;property_type&#39;, hue=&#39;neighbourhood&#39;, data=propertyRatio) plt.title(&#39;Ratio of Property Type, split by location area&#39;, fontdict= {&#39;fontsize&#39;: 24}) plt.xlabel(&#39;Property Type&#39;, fontdict= {&#39;fontsize&#39;: 18}) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . 5.2.2 Property Type Accommodation Price . propertyPricing = listings_clean.groupby(&#39;property_type&#39;).price.mean().to_frame().sort_values(by=&#39;price&#39;, ascending=False).reset_index() #Viz plt.figure(figsize= (10, 10)) plt.style.use(&#39;ggplot&#39;) sns.barplot(propertyPricing.price, propertyPricing.property_type) plt.title(&#39;Accommodation Prices, split by Property Type&#39;, fontdict= {&#39;fontsize&#39;: 24}) #plt.yscale(&#39;log&#39;) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. . 5.2.3 Conclusion on the Analysis of Property Types . Looking at the property types, we find that apartments are most often listen on Airbnb, either as a private room or the entire apartment. It comes to no surprise, that pricings vary by property type, with with private rooms in apartments being the cheepest with a flat 600 kr fee per night. In relation an entire apartment can be rented for just below an average of 1200 kr. per night. . Going, further into the data, we look at how the ratios between the property types varies. We notice that for Brønshøj-Husum and Vanløse a great deal of the listings are entire houses, while the ratio in these cities for entire apartments are relatively low. This could imply, that these to neighbourhoods are more family friendly. . 5.3 Investigating Room Types . 5.3.1 Room Types in Copenhagen . rooms = clean[[&#39;room_type&#39;]].value_counts().to_frame(name=&#39;listings&#39;).reset_index() #Viz plt.figure(figsize= (10, 10)) plt.style.use(&#39;ggplot&#39;) sns.barplot(rooms.room_type, rooms.listings) plt.title(&#39;Accommodation Options Split by Room Type, log_scale&#39;, fontdict= {&#39;fontsize&#39;: 24}) plt.yscale(&#39;log&#39;) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. . 5.3.2 Room Types by Neighbourhood . #Count number of listings in neighbourhoods by property type roomCount = clean.groupby([&#39;neighbourhood&#39;,&#39;room_type&#39;]).neighbourhood.count().to_frame(name = &#39;listings&#39;).reset_index() #Sum number of listings per neighbourhood roomCount = roomCount.merge(neighbourhoods, on=&#39;neighbourhood&#39;) #Calculate ratio of property types in the different neighbourhoods roomCount[&#39;room_ratio&#39;] = roomCount[&#39;listings&#39;]/roomCount[&#39;total_listings&#39;] roomRatio = roomCount #Viz plt.figure(figsize= (25, 15)) plt.style.use(&#39;ggplot&#39;) sns.barplot(y=&#39;room_ratio&#39;, x=&#39;room_type&#39;, hue=&#39;neighbourhood&#39;, data=roomRatio) plt.title(&#39;Ratio of Room Type, split by location area&#39;, fontdict= {&#39;fontsize&#39;: 24}) plt.xlabel(&#39;Room Type&#39;, fontdict= {&#39;fontsize&#39;: 18}) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . 5.3.3 Room Type Accommodation Prices . roomPricing = listings.groupby(&#39;room_type&#39;).price.mean().to_frame().sort_values(by=&#39;price&#39;, ascending=False).reset_index() #Viz plt.figure(figsize= (10, 10)) plt.style.use(&#39;ggplot&#39;) sns.barplot(roomPricing.price, roomPricing.room_type) plt.title(&#39;Accommodation Prices, split by Room Type&#39;, fontdict= {&#39;fontsize&#39;: 24}) #plt.yscale(&#39;log&#39;) plt.tick_params(labelsize= 16) plt.savefig(&#39;categories_top_20.png&#39;) . /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. . 5.3.4 Conclusions on the Analysis of Room Types . Interestingly, we find Hotel rooms to be promoted through the Airbnb platform as an alternative to the private housings. Even more interestingly, is it, however to no surprise, that the price for a hotel room for outpasses the pricing for private room. Hotel rooms are more than 50% more expensive than, a private room. Moreover, an entire apartment/house is just 300 kr. more per night, at about 1200 kr. . 5.4 Geo Spacial Map . If you are interested in interacting with the airbnb listings, we have here provided you with an interactive map, that visually displays the locations of each listing, color-coded by neighbourhoods. Looking at the density of the listings, you can quickly get an idea of which location is mostly popular, and pricing is displayed by the sice of each point. . #Define mapbox API token and style mapbox_access_token = &#39;pk.eyJ1IjoiYWNodG9uMjExMSIsImEiOiJja2lyam5yemgyNTV0MnJsYmJ0NXdzNWRxIn0.rWJgur27hJnWoBt7Oq5LeQ&#39; px.set_mapbox_access_token(mapbox_access_token) plot_style = &#39;mapbox://styles/achton2111/ckirsv5df0aj01at4zp0d7f3w&#39; #Interactive Geospacial plot fig = px.scatter_mapbox(clean, lat=&quot;latitude&quot;, lon=&quot;longitude&quot;, color=&quot;neighbourhood&quot;, zoom=11, size=&#39;price&#39;, mapbox_style= plot_style, hover_name=&#39;listing_name&#39;, hover_data = {&#39;listing_id&#39;, &#39;property_type&#39;, &#39;room_type&#39;, &#39;accommodates&#39;, &#39;bedrooms&#39;, &#39;beds&#39;, &#39;number_of_reviews&#39;, &#39;last_review&#39;, &#39;price&#39;, &#39;review_scores_rating&#39;}, title = &#39;AirBnB Listing Locations. Coloured by Neighbourhood, Size by Price)&#39; ) fig.show() . . . 5.5 WordClouds . Let&#39;s try to see if there are any visual differences in how the hosts has described their location. These wordclouds visualize words that were most commonly used to describe the neighbourhood. . clean.dropna(inplace=True) #Distinction between neighbourhoods norrebro = clean[clean.neighbourhood == &#39;Nørrebro&#39;] indreby = clean[clean.neighbourhood == &#39;Indre By&#39;] vesterbro_KgsEnghave = clean[clean.neighbourhood == &#39;Vesterbro-Kongens Enghave&#39;] osterbro =clean[clean.neighbourhood == &#39;Østerbro&#39;] frederiksberg = clean[clean.neighbourhood == &#39;Frederiksberg&#39;] amagerOst = clean[clean.neighbourhood == &#39;Amager Øst&#39;] amagerVest = clean[clean.neighbourhood == &#39;Amager Vest&#39;] valby = clean[clean.neighbourhood == &#39;Valby&#39;] bispebjerg = clean[clean.neighbourhood == &#39;Bispebjerg&#39;] vanlose = clean[clean.neighbourhood == &#39;Vanløse&#39;] bronshojHusum = clean[clean.neighbourhood == &#39;Brønshøj-Husum&#39;] . Norrebro . # Iterating through the .csv data file for i in norrebro.listing_description: i = str(i) separate = i.split() #split each word in a row for j in range(len(separate)): separate[j] = separate[j].lower() #convert words to lower case comment_words += &quot; &quot;.join(separate)+&quot; &quot; #Join the words together. Comment_words now contains all words in the data # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . # Iterating through the .csv data file for i in norrebro.neighbourhood_description: i = str(i) separate = i.split() #split each word in a row for j in range(len(separate)): separate[j] = separate[j].lower() #convert words to lower case comment_words += &quot; &quot;.join(separate)+&quot; &quot; #Join the words together. Comment_words now contains all words in the data # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Indre By . # Iterating through the .csv data file for i in indreby.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Vesterbro - Kongens Enghave . # Iterating through the .csv data file for i in vesterbro_KgsEnghave.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . &#216;sterbro . # Iterating through the .csv data file for i in osterbro.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Frederiksberg . # Iterating through the .csv data file for i in frederiksberg.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Amager &#216;st . # Iterating through the .csv data file for i in amagerOst.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Amager Vest . # Iterating through the .csv data file for i in amagerVest.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Valby . # Iterating through the .csv data file for i in valby.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Bispebjerg . # Iterating through the .csv data file for i in bispebjerg.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Vanl&#248;se . # Iterating through the .csv data file for i in vanlose.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . Br&#248;nsh&#248;j - Husum . # Iterating through the .csv data file for i in bronshojHusum.neighbourhood_description: i = str(i) separate = i.split() for j in range(len(separate)): separate[j] = separate[j].lower() comment_words += &quot; &quot;.join(separate)+&quot; &quot; # Creating the Word Cloud final_wordcloud = WordCloud(width = 3000, height = 2000, background_color =&#39;black&#39;, stopwords = STOPWORDS, min_font_size = 10).generate(comment_words) # Displaying the WordCloud plt.figure(facecolor = None) plt.imshow(final_wordcloud) plt.axis(&quot;off&quot;) plt.tight_layout(pad = 0) plt.show() . 6.0 DISCUSSION AND CONCLUSION . In this project we analyzed different features associated with airbnb listings in special relation to the neighbourhoods. We found that guests that are traveling by group might seek accommodation in the city center, as it offers a unique opportunity to be right in the center of the city, while keeping the cost down. Families, however, might seek to the outer copenhagen areas such as Husum to find a cosy house to stay in. . While wordclouds has been created as a means to understand the words or narratives that describes a location, they fail to give much insight. We suggest further investigating the data through Sentiment analysis or Natural Language Processing techniques, that can further preprocess the textual data, tokenize it and create predictive models that in a more meaningful way will be able to describe these sought after narratives. .",
            "url": "https://achnito.github.io/BDBI/exploratory%20data%20analysis/data%20visualization/wordcloud/airbnb/neighbourhoods%20in%20copenhagen/accommodation%20pricing/2020/12/18/AirBnb.html",
            "relUrl": "/exploratory%20data%20analysis/data%20visualization/wordcloud/airbnb/neighbourhoods%20in%20copenhagen/accommodation%20pricing/2020/12/18/AirBnb.html",
            "date": " • Dec 18, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://achnito.github.io/BDBI/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://achnito.github.io/BDBI/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://achnito.github.io/BDBI/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://achnito.github.io/BDBI/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}